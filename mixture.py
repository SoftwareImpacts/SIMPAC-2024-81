import copy
from typing import List
import numpy as np
import static_functions
import log_functions
import inputs
from molecule import Molecule


class Mixture:
    """
    A class to represent a mixture of molecules.

    This class manages the creation and manipulation of a collection of molecules, tracking their
    properties such as potential energy, weight, and molecular weight. It supports operations
    like initializing the mixture from a global dictionary, sorting molecules, updating mixture
    information, generating Sobol positions for molecule placement, and calculating the Lennard-Jones
    potential energy.

    Attributes
    ----------
    _id : int
        A class variable to keep track of the number of Mixture instances.
    potential_energy : float
        The potential energy of the mixture.
    nbr_of_mols : int
        The number of molecules in the mixture.
    weight : float
        The total weight of the mixture.
    mw_gmol : float
        The molecular weight of the mixture in g/mol.
    box_dims : List[float]
        The dimensions of the simulation box.
    box_final_cubic_dim : float
        The final cubic dimension of the simulation box.
    molecules : List[Molecule]
        A list of molecules in the mixture.
    molecules_set : List[Molecule]
        A list of unique molecules in the mixture.
    sobol_x : list
        X-coordinates generated by Sobol sequence.
    sobol_y : list
        Y-coordinates generated by Sobol sequence.
    sobol_z : list
        Z-coordinates generated by Sobol sequence.
    accepted : bool
        Flag indicating if the mixture's potential energy is within an acceptable range.
    """

    _id: int = 0  # Class variable to keep track of the number of Mixture instances

    @log_functions.track_call_depth
    def __init__(self) -> None:
        """
        Initializes a new instance of the Mixture class, setting up the mixture's properties and
        generating initial molecular positions.
        """
        Molecule.reset_counters()
        Mixture._id += 1
        self.potential_energy: float = 0
        self.nbr_of_mols: int = 0
        self.weight: float = 0
        self.mw_gmol: float = 0
        self.box_dims: List[float] = [0, 0, 0]
        self.molecules: List[Molecule] = []
        self.molecules_set: List[Molecule] = []

        # Populate molecules based on global dictionary
        self._initialize_mixture_molecules()

        # Update mixture information
        self.update_mixture_information()

        self.sobol_x = []
        self.sobol_y = []
        self.sobol_z = []

        # Generate Sobol positions
        self.generate_sobol_positions()

        self.accepted = False

    @log_functions.track_call_depth
    def _initialize_mixture_molecules(self) -> None:
        """
        Initializes the molecules in the mixture based on a predefined global dictionary, handling
        duplication and rotation as specified.
        """
        for key, value in inputs.molecules_dictionary.items():
            self.molecules.append(Molecule(name=key, info=value))
            self.molecules_set.append(self.molecules[-1])
            for _ in range(value["nbr_of_mols"] - 1):
                duplicate_molecule = copy.deepcopy(self.molecules[-1])
                duplicate_molecule.update_name_and_id()
                if value["rotate"]:
                    duplicate_molecule.randomly_rotate_mol()
                self.molecules.append(duplicate_molecule)
        self.sort_molecules_by_type()

    @log_functions.track_call_depth
    def sort_molecules_by_type(self) -> None:
        """
        Sorts the molecules in the mixture by their type.
        """
        self.molecules = sorted(self.molecules, key=lambda x: x.type)

    @log_functions.track_call_depth
    def update_mixture_information(self) -> None:
        """
        Updates the mixture information including weight, number of molecules, molecular weight,
        and box dimensions based on current molecules in the mixture.
        """
        # Update weight and number of molecules
        for molecule in self.molecules:
            self.weight += molecule.mw_gmol
            self.nbr_of_mols += 1

        # Calculate molecular weight
        self.mw_gmol = self.weight / self.nbr_of_mols

        # if simulation is not cubic:
        # Calculate simulation box dimensions
        # self.box_dims = [
        #     self.box_final_cubic_dim,
        #     self.box_final_cubic_dim,
        #     self._calculate_box_initial_c_dim(self.box_final_cubic_dim),
        # ]
        initial_cubic_dimension = self._calculate_box_initial_cubic()
        self.box_dims = [
            initial_cubic_dimension,
            initial_cubic_dimension,
            initial_cubic_dimension,
        ]

    @log_functions.track_call_depth
    def _calculate_box_initial_cubic(self) -> float:
        """
        Calculates the initial cubic dimension of the simulation box based on the number of molecules,
        molecular weight, and predefined density factors.

        Returns
        -------
        float
            The initial cubic dimension of the simulation box.
        """
        return (
            self.nbr_of_mols
            * self.mw_gmol
            / 1000
            / (inputs.density)
            / inputs.AVOGADRO_NUMBER
        ) ** (1 / 3) * 1e10

    @log_functions.track_call_depth
    def generate_sobol_positions(self) -> None:
        """
        Generates Sobol sequence positions for the placement of molecules in the simulation box,
        taking into account layer offsets.
        """
        (
            self.sobol_x,
            self.sobol_y,
            self.sobol_z,
        ) = static_functions.generate_sobol_positions(
            num_points=self.nbr_of_mols,
            box_dims=(
                self.box_dims[0] - inputs.layer_offset,
                self.box_dims[1] - inputs.layer_offset,
                self.box_dims[2] - inputs.layer_offset,
            ),
        )

        # Shifting Sobol points in the z dimension to have offsets offset/2 units long:
        self.sobol_x = [i + inputs.layer_offset / 2 for i in self.sobol_x]
        self.sobol_y = [i + inputs.layer_offset / 2 for i in self.sobol_y]
        self.sobol_z = [i + inputs.layer_offset / 2 for i in self.sobol_z]

    @log_functions.track_call_depth
    def translate_molecules_to_sobol_positions(self) -> None:
        """
        Translates molecules in the mixture to their respective positions generated by the Sobol sequence.
        """
        for index, molecule in enumerate(self.molecules):
            static_functions.translate_molecule(
                mol_obj=molecule.mol_obj,
                x=self.sobol_x[index],
                y=self.sobol_y[index],
                z=self.sobol_z[index],
            )

    @log_functions.track_call_depth
    def calculate_lj_potential_energy(self) -> None:
        """
        Calculates the Lennard-Jones potential energy of the mixture and updates the accepted status
        based on a predefined energy limit.
        """
        # Extracting the atoms' positions:
        (
            atoms_pos_x,
            atoms_pos_y,
            atoms_pos_z,
        ) = static_functions.extract_atom_positions_from_mol_obj_list(
            mol_obj_list=[molecule.mol_obj for molecule in self.molecules]
        )

        # Calculate Lennard-Jones potential energy:
        self.potential_energy = static_functions.compute_total_lj_potential(
            x=np.array(atoms_pos_x),
            y=np.array(atoms_pos_y),
            z=np.array(atoms_pos_z),
            box_dimensions=tuple(self.box_dims),
            rcut=inputs.cutoff_distance,
        )

        # Determine if the potential energy is accepted based on a limit:
        self.accepted = self.potential_energy < inputs.energy_threshold
